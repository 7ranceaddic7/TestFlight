@PART[*]:HAS[@MODULE[ModuleEngines]:HAS[@PROPELLANT[LiquidFuel]]]:FINAL
{
	// The TestFlightCore module is, well, the core of the entire system and controls all the other pieces
	// Every part that uses TestFlight *must* have a TestFlightCore module or it won't connect to the 
	// overall system.
	// There should only ever be a SINGLE TestFlightCore module on a part.
    MODULE
    {
        name = TestFlightCore
        // By leaving these two frequencies at 0, we simply let the global frequency take over
        // We could however make this one part poll, or check for failures, LESS often by setting higher values here
        pollingInterval = 0
        failureCheckFrequency = 0
    }
	// The TestFlightRecorder module is the second module required by the system.  This module is responsible
    // for collecting flight data, and thus the system is pretty useless without it.  This module defines
    // how the part gains flight data over time.  
    // There are different types of FlightRecorder modules, and mods can add new ones.
	// There should only ever be a SINGLE TestFlightRecorder module on a part.
    MODULE
    {
        name = FlightDataRecorder_Engine
        // The data multiplier indicates, ROUGHLY, how many points of Flight Data
        // is accumulated per second of Mission Elapsed Time
        flightDataMultiplier = 10
        // The data engineer modifier is a bonus per level of engineer skill available in the vessel's crew
        flightDataEngineerModifier = 0.25
    }
	// The TestFlightReliability module is responsible for calculating the reliability of the part based
	// on flight data and given scope.  Again, there can be multiple of these modules, each canculating
	// reliability differently.  
	// You can have MULTIPLE Reliability modules on a single part.
    MODULE
    {
        name = TestFlightReliability
        // factor and multiplier control the difficulty curve of the realiabilty value
        // reliability = (flightData * realiabilityMultiplier) ^ (1/reliabilityFactor)
        reliabilityFactor = 2
        reliabilityMultipler = 3
        // The module can have one or more RELIABILITY_BODY nodes.  Each defines the min and max reliability
        // for a given "Scope".
        RELIABILITY_BODY
        {
            scope = kerbin_atmosphere
            reliabilityCurve
            {
				key = 0 0.5
				key = 311.7036 0.7235439 0.000154673 0.000154673
				key = 1243.905 0.9121472 6.378564E-05 4.212264E-05
				key = 10000 1 4.000178E-06 2.5E-05            
            }
        }
        RELIABILITY_BODY
        {
            scope = kerbin_space
            reliabilityCurve
            {
				key = 0 0.5
				key = 311.7036 0.7235439 0.000154673 0.000154673
				key = 1243.905 0.9121472 6.378564E-05 4.212264E-05
				key = 10000 1 4.000178E-06 2.5E-05            
            }
        }
    }
	// The TestFlightFailure module is the last type of module in the system.  Each TestFlightFailure module
	// defines a specific type of failure that can occur, and is responsible for causing that failure when
	// told to, and for repairing the failure when told to.
    MODULE
    {
        name = TestFlightFailure_ShutdownEngine
        // User friendly name to identify the failure in the MSD.  Maximum of 25 characters!
        failureTitle = Engine Shutdown
        // Failure type can be either "mechanical" or "software".
        // Mechanical failures are physical failures of parts and require a Kerbal on site to repair it
        // Software failures are electrical or software glitches and can be repaired remotely
        failureType = software
        // Severity of the failure: minor, failure, major
        // As a rule of thumb, minor failures should only hinder a vessel or mission, but not directly put it in danger
        severity = failure
        // ** PLEASE USE ONLY THESE WEIGHTS **
        // The weight of the failure is how likely it is to occur RELATIVE to other failures defined on the same part
        // 2 = Rare, 4 = Seldom, 8 = Average, 16 = Often, 32 = Common
        weight = 4
        // If the failure can be repaired, then a REPAIR node mst be defined
        // If no FAILURE node is defined then hte failure can not be repaired
        REPAIR
        {
        	// For PHYSICAL failures
            // canBeRepairedOnSplashed = False
            // canBeRepairedInFlight = False
            // requiresEVA = False
            // replacementPart = SpareParts
            // replacementPartOptional = True
            // replacementPartBonus = 0.05
            // For SOFTWARE failures
            canBeRepairedByRemote = True
            dataScale = 1
            dataSize= 1
            // For all failures
            repairChance = 75
        }
    }
    MODULE
    {
        name = TestFlightFailure_LockGimbal
        failureTitle = Gimbal Failure
        failureType = mechanical
        severity = failure
        // ** PLEASE USE ONLY THESE WEIGHTS **
        // The weight of the failure is how likely it is to occur RELATIVE to other failures defined on the same part
        // 2 = Rare, 4 = Seldom, 8 = Average, 16 = Often, 32 = Common
        weight = 8
        REPAIR
        {
        	// For PHYSICAL failures
            canBeRepairedOnSplashed = False
            canBeRepairedInFlight = False
            requiresEVA = False
            replacementPart = HydraulicPiston
            replacementPartOptional = True
            replacementPartBonus = 0.10
            // For SOFTWARE failures
            // canBeRepairedByRemote
            // dataScale
            // dataSize
            // For all failures
            repairChance = 50
        }
    }
    MODULE
    {
        name = TestFlightFailure_ReducedMaxThrust
        failureTitle = Loss of Thrust
        failureType = mechanical
        severity = failure
        // ** PLEASE USE ONLY THESE WEIGHTS **
        // The weight of the failure is how likely it is to occur RELATIVE to other failures defined on the same part
        // 2 = Rare, 4 = Seldom, 8 = Average, 16 = Often, 32 = Common
        weight = 32
        REPAIR
        {
        	// For PHYSICAL failures
            canBeRepairedOnSplashed = False
            canBeRepairedInFlight = False
            replacementPart = NONE
            requiresEVA = False
            // For SOFTWARE failures
            // canBeRepairedByRemote
            // dataScale
            // dataSize
            // For all failures
            repairChance = 100
        }
    }
	MODULE
	{
		name = TestFlightFailure_Explode
		failureTitle = Part Exploded!
		failureType = mechanical
		severity = major
		weight = 2
	}
}
@PART[*]:HAS[@MODULE[ModuleEngines],@RESOURCE[SolidFuel]]:FINAL
{
	// The TestFlightCore module is, well, the core of the entire system and controls all the other pieces
	// Every part that uses TestFlight *must* have a TestFlightCore module or it won't connect to the 
	// overall system.
	// There should only ever be a SINGLE TestFlightCore module on a part.
    MODULE
    {
        name = TestFlightCore
        // By leaving these two frequencies at 0, we simply let the global frequency take over
        // We could however make this one part poll, or check for failures, LESS often by setting higher values here
        pollingInterval = 0
        failureCheckFrequency = 0
    }
	// The TestFlightRecorder module is the second module required by the system.  This module is responsible
    // for collecting flight data, and thus the system is pretty useless without it.  This module defines
    // how the part gains flight data over time.  
    // There are different types of FlightRecorder modules, and mods can add new ones.
	// There should only ever be a SINGLE TestFlightRecorder module on a part.
    MODULE
    {
        name = FlightDataRecorder_Engine
        // The data multiplier indicates, ROUGHLY, how many points of Flight Data
        // is accumulated per second of Mission Elapsed Time
        flightDataMultiplier = 10
        // The data engineer modifier is a bonus per level of engineer skill available in the vessel's crew
        flightDataEngineerModifier = 0.25
    }
	// The TestFlightReliability module is responsible for calculating the reliability of the part based
	// on flight data and given scope.  Again, there can be multiple of these modules, each canculating
	// reliability differently.  
	// You can have MULTIPLE Reliability modules on a single part.
    MODULE
    {
        name = TestFlightReliability
        // factor and multiplier control the difficulty curve of the realiabilty value
        // reliability = (flightData * realiabilityMultiplier) ^ (1/reliabilityFactor)
        reliabilityFactor = 2
        reliabilityMultipler = 3
        // The module can have one or more RELIABILITY_BODY nodes.  Each defines the min and max reliability
        // for a given "Scope".
        RELIABILITY_BODY
        {
            scope = kerbin_atmosphere
            reliabilityCurve
            {
				key = 0 0.5
				key = 311.7036 0.7235439 0.000154673 0.000154673
				key = 1243.905 0.9121472 6.378564E-05 4.212264E-05
				key = 10000 1 4.000178E-06 2.5E-05            
            }
        }
        RELIABILITY_BODY
        {
            scope = kerbin_space
            reliabilityCurve
            {
				key = 0 0.5
				key = 311.7036 0.7235439 0.000154673 0.000154673
				key = 1243.905 0.9121472 6.378564E-05 4.212264E-05
				key = 10000 1 4.000178E-06 2.5E-05            
            }
        }
    }
	// The TestFlightFailure module is the last type of module in the system.  Each TestFlightFailure module
	// defines a specific type of failure that can occur, and is responsible for causing that failure when
	// told to, and for repairing the failure when told to.
    MODULE
    {
        name = TestFlightFailure_ShutdownEngine
        // User friendly name to identify the failure in the MSD.  Maximum of 25 characters!
        failureTitle = Engine Shutdown
        // Failure type can be either "mechanical" or "software".
        // Mechanical failures are physical failures of parts and require a Kerbal on site to repair it
        // Software failures are electrical or software glitches and can be repaired remotely
        failureType = software
        // Severity of the failure: minor, failure, major
        // As a rule of thumb, minor failures should only hinder a vessel or mission, but not directly put it in danger
        severity = failure
        // ** PLEASE USE ONLY THESE WEIGHTS **
        // The weight of the failure is how likely it is to occur RELATIVE to other failures defined on the same part
        // 2 = Rare, 4 = Seldom, 8 = Average, 16 = Often, 32 = Common
        weight = 4
        // If the failure can be repaired, then a REPAIR node mst be defined
        // If no FAILURE node is defined then hte failure can not be repaired
        REPAIR
        {
        	// For PHYSICAL failures
            // canBeRepairedOnSplashed = False
            // canBeRepairedInFlight = False
            // requiresEVA = False
            // replacementPart = SpareParts
            // replacementPartOptional = True
            // replacementPartBonus = 0.05
            // For SOFTWARE failures
            canBeRepairedByRemote = True
            dataScale = 1
            dataSize= 1
            // For all failures
            repairChance = 75
        }
    }
    MODULE
    {
        name = TestFlightFailure_LockGimbal
        failureTitle = Gimbal Failure
        failureType = mechanical
        severity = failure
        // ** PLEASE USE ONLY THESE WEIGHTS **
        // The weight of the failure is how likely it is to occur RELATIVE to other failures defined on the same part
        // 2 = Rare, 4 = Seldom, 8 = Average, 16 = Often, 32 = Common
        weight = 8
        REPAIR
        {
        	// For PHYSICAL failures
            canBeRepairedOnSplashed = False
            canBeRepairedInFlight = False
            requiresEVA = False
            replacementPart = HydraulicPiston
            replacementPartOptional = True
            replacementPartBonus = 0.10
            // For SOFTWARE failures
            // canBeRepairedByRemote
            // dataScale
            // dataSize
            // For all failures
            repairChance = 50
        }
    }
    MODULE
    {
        name = TestFlightFailure_ReducedMaxThrust
        failureTitle = Loss of Thrust
        failureType = mechanical
        severity = failure
        // ** PLEASE USE ONLY THESE WEIGHTS **
        // The weight of the failure is how likely it is to occur RELATIVE to other failures defined on the same part
        // 2 = Rare, 4 = Seldom, 8 = Average, 16 = Often, 32 = Common
        weight = 32
        REPAIR
        {
        	// For PHYSICAL failures
            canBeRepairedOnSplashed = False
            canBeRepairedInFlight = False
            replacementPart = NONE
            requiresEVA = False
            // For SOFTWARE failures
            // canBeRepairedByRemote
            // dataScale
            // dataSize
            // For all failures
            repairChance = 100
        }
    }
	MODULE
	{
		name = TestFlightFailure_Explode
		failureTitle = Part Exploded!
		failureType = mechanical
		severity = major
		weight = 2
	}
}
@PART[*]:HAS[@MODULE[ModuleEngines]:HAS[@PROPELLANT[MonoPropellant]]]:FINAL
{
	// The TestFlightCore module is, well, the core of the entire system and controls all the other pieces
	// Every part that uses TestFlight *must* have a TestFlightCore module or it won't connect to the 
	// overall system.
	// There should only ever be a SINGLE TestFlightCore module on a part.
    MODULE
    {
        name = TestFlightCore
        // By leaving these two frequencies at 0, we simply let the global frequency take over
        // We could however make this one part poll, or check for failures, LESS often by setting higher values here
        pollingInterval = 0
        failureCheckFrequency = 0
    }
	// The TestFlightRecorder module is the second module required by the system.  This module is responsible
    // for collecting flight data, and thus the system is pretty useless without it.  This module defines
    // how the part gains flight data over time.  
    // There are different types of FlightRecorder modules, and mods can add new ones.
	// There should only ever be a SINGLE TestFlightRecorder module on a part.
    MODULE
    {
        name = FlightDataRecorder_Engine
        // The data multiplier indicates, ROUGHLY, how many points of Flight Data
        // is accumulated per second of Mission Elapsed Time
        flightDataMultiplier = 10
        // The data engineer modifier is a bonus per level of engineer skill available in the vessel's crew
        flightDataEngineerModifier = 0.25
    }
	// The TestFlightReliability module is responsible for calculating the reliability of the part based
	// on flight data and given scope.  Again, there can be multiple of these modules, each canculating
	// reliability differently.  
	// You can have MULTIPLE Reliability modules on a single part.
    MODULE
    {
        name = TestFlightReliability
        // factor and multiplier control the difficulty curve of the realiabilty value
        // reliability = (flightData * realiabilityMultiplier) ^ (1/reliabilityFactor)
        reliabilityFactor = 2
        reliabilityMultipler = 3
        // The module can have one or more RELIABILITY_BODY nodes.  Each defines the min and max reliability
        // for a given "Scope".
        RELIABILITY_BODY
        {
            scope = kerbin_atmosphere
            reliabilityCurve
            {
				key = 0 0.5
				key = 311.7036 0.7235439 0.000154673 0.000154673
				key = 1243.905 0.9121472 6.378564E-05 4.212264E-05
				key = 10000 1 4.000178E-06 2.5E-05            
            }
        }
        RELIABILITY_BODY
        {
            scope = kerbin_space
            reliabilityCurve
            {
				key = 0 0.5
				key = 311.7036 0.7235439 0.000154673 0.000154673
				key = 1243.905 0.9121472 6.378564E-05 4.212264E-05
				key = 10000 1 4.000178E-06 2.5E-05            
            }
        }
    }
	// The TestFlightFailure module is the last type of module in the system.  Each TestFlightFailure module
	// defines a specific type of failure that can occur, and is responsible for causing that failure when
	// told to, and for repairing the failure when told to.
    MODULE
    {
        name = TestFlightFailure_ShutdownEngine
        // User friendly name to identify the failure in the MSD.  Maximum of 25 characters!
        failureTitle = Engine Shutdown
        // Failure type can be either "mechanical" or "software".
        // Mechanical failures are physical failures of parts and require a Kerbal on site to repair it
        // Software failures are electrical or software glitches and can be repaired remotely
        failureType = software
        // Severity of the failure: minor, failure, major
        // As a rule of thumb, minor failures should only hinder a vessel or mission, but not directly put it in danger
        severity = failure
        // ** PLEASE USE ONLY THESE WEIGHTS **
        // The weight of the failure is how likely it is to occur RELATIVE to other failures defined on the same part
        // 2 = Rare, 4 = Seldom, 8 = Average, 16 = Often, 32 = Common
        weight = 4
        // If the failure can be repaired, then a REPAIR node mst be defined
        // If no FAILURE node is defined then hte failure can not be repaired
        REPAIR
        {
        	// For PHYSICAL failures
            // canBeRepairedOnSplashed = False
            // canBeRepairedInFlight = False
            // requiresEVA = False
            // replacementPart = SpareParts
            // replacementPartOptional = True
            // replacementPartBonus = 0.05
            // For SOFTWARE failures
            canBeRepairedByRemote = True
            dataScale = 1
            dataSize= 1
            // For all failures
            repairChance = 75
        }
    }
    MODULE
    {
        name = TestFlightFailure_LockGimbal
        failureTitle = Gimbal Failure
        failureType = mechanical
        severity = failure
        // ** PLEASE USE ONLY THESE WEIGHTS **
        // The weight of the failure is how likely it is to occur RELATIVE to other failures defined on the same part
        // 2 = Rare, 4 = Seldom, 8 = Average, 16 = Often, 32 = Common
        weight = 8
        REPAIR
        {
        	// For PHYSICAL failures
            canBeRepairedOnSplashed = False
            canBeRepairedInFlight = False
            requiresEVA = False
            replacementPart = HydraulicPiston
            replacementPartOptional = True
            replacementPartBonus = 0.10
            // For SOFTWARE failures
            // canBeRepairedByRemote
            // dataScale
            // dataSize
            // For all failures
            repairChance = 50
        }
    }
    MODULE
    {
        name = TestFlightFailure_ReducedMaxThrust
        failureTitle = Loss of Thrust
        failureType = mechanical
        severity = failure
        // ** PLEASE USE ONLY THESE WEIGHTS **
        // The weight of the failure is how likely it is to occur RELATIVE to other failures defined on the same part
        // 2 = Rare, 4 = Seldom, 8 = Average, 16 = Often, 32 = Common
        weight = 32
        REPAIR
        {
        	// For PHYSICAL failures
            canBeRepairedOnSplashed = False
            canBeRepairedInFlight = False
            replacementPart = NONE
            requiresEVA = False
            // For SOFTWARE failures
            // canBeRepairedByRemote
            // dataScale
            // dataSize
            // For all failures
            repairChance = 100
        }
    }
	MODULE
	{
		name = TestFlightFailure_Explode
		failureTitle = Part Exploded!
		failureType = mechanical
		severity = major
		weight = 2
	}
}
@PART[*]:HAS[@MODULE[ModuleRCS],!MODULE[ModuleCommand]]:FINAL
{
	// The TestFlightCore module is, well, the core of the entire system and controls all the other pieces
	// Every part that uses TestFlight *must* have a TestFlightCore module or it won't connect to the 
	// overall system.
	// There should only ever be a SINGLE TestFlightCore module on a part.
    MODULE
    {
        name = TestFlightCore
        // By leaving these two frequencies at 0, we simply let the global frequency take over
        // We could however make this one part poll, or check for failures, LESS often by setting higher values here
        pollingInterval = 0
        failureCheckFrequency = 0
    }
	// The TestFlightRecorder module is the second module required by the system.  This module is responsible
    // for collecting flight data, and thus the system is pretty useless without it.  This module defines
    // how the part gains flight data over time.  
    // There are different types of FlightRecorder modules, and mods can add new ones.
	// There should only ever be a SINGLE TestFlightRecorder module on a part.
    MODULE
    {
        name = FlightDataRecorder_Engine
        // The data multiplier indicates, ROUGHLY, how many points of Flight Data
        // is accumulated per second of Mission Elapsed Time
        flightDataMultiplier = 5
        // The data engineer modifier is a bonus per level of engineer skill available in the vessel's crew
        flightDataEngineerModifier = 0.10
    }
	// The TestFlightReliability module is responsible for calculating the reliability of the part based
	// on flight data and given scope.  Again, there can be multiple of these modules, each canculating
	// reliability differently.  
	// You can have MULTIPLE Reliability modules on a single part.
    MODULE
    {
        name = TestFlightReliability
        // factor and multiplier control the difficulty curve of the realiabilty value
        // reliability = (flightData * realiabilityMultiplier) ^ (1/reliabilityFactor)
        reliabilityFactor = 2
        reliabilityMultipler = 3
        // The module can have one or more RELIABILITY_BODY nodes.  Each defines the min and max reliability
        // for a given "Scope".
        RELIABILITY_BODY
        {
            scope = kerbin_atmosphere
            reliabilityCurve
            {
				key = 0 0.5
				key = 311.7036 0.7235439 0.000154673 0.000154673
				key = 1243.905 0.9121472 6.378564E-05 4.212264E-05
				key = 10000 1 4.000178E-06 2.5E-05            
            }
        }
        RELIABILITY_BODY
        {
            scope = kerbin_space
            reliabilityCurve
            {
				key = 0 0.5
				key = 311.7036 0.7235439 0.000154673 0.000154673
				key = 1243.905 0.9121472 6.378564E-05 4.212264E-05
				key = 10000 1 4.000178E-06 2.5E-05            
            }
        }
    }
	// The TestFlightFailure module is the last type of module in the system.  Each TestFlightFailure module
	// defines a specific type of failure that can occur, and is responsible for causing that failure when
	// told to, and for repairing the failure when told to.
    MODULE
    {
        name = TestFlightFailure_ShutdownEngine
        // User friendly name to identify the failure in the MSD.  Maximum of 25 characters!
        failureTitle = Engine Shutdown
        // Failure type can be either "mechanical" or "software".
        // Mechanical failures are physical failures of parts and require a Kerbal on site to repair it
        // Software failures are electrical or software glitches and can be repaired remotely
        failureType = software
        // Severity of the failure: minor, failure, major
        // As a rule of thumb, minor failures should only hinder a vessel or mission, but not directly put it in danger
        severity = failure
        // ** PLEASE USE ONLY THESE WEIGHTS **
        // The weight of the failure is how likely it is to occur RELATIVE to other failures defined on the same part
        // 2 = Rare, 4 = Seldom, 8 = Average, 16 = Often, 32 = Common
        weight = 4
        // If the failure can be repaired, then a REPAIR node mst be defined
        // If no FAILURE node is defined then hte failure can not be repaired
        REPAIR
        {
        	// For PHYSICAL failures
            // canBeRepairedOnSplashed = False
            // canBeRepairedInFlight = False
            // requiresEVA = False
            // replacementPart = SpareParts
            // replacementPartOptional = True
            // replacementPartBonus = 0.05
            // For SOFTWARE failures
            canBeRepairedByRemote = True
            dataScale = 1
            dataSize= 1
            // For all failures
            repairChance = 75
        }
    }
    MODULE
    {
        name = TestFlightFailure_LockGimbal
        failureTitle = Gimbal Failure
        failureType = mechanical
        severity = failure
        // ** PLEASE USE ONLY THESE WEIGHTS **
        // The weight of the failure is how likely it is to occur RELATIVE to other failures defined on the same part
        // 2 = Rare, 4 = Seldom, 8 = Average, 16 = Often, 32 = Common
        weight = 8
        REPAIR
        {
        	// For PHYSICAL failures
            canBeRepairedOnSplashed = False
            canBeRepairedInFlight = False
            requiresEVA = False
            replacementPart = HydraulicPiston
            replacementPartOptional = True
            replacementPartBonus = 0.10
            // For SOFTWARE failures
            // canBeRepairedByRemote
            // dataScale
            // dataSize
            // For all failures
            repairChance = 50
        }
    }
    MODULE
    {
        name = TestFlightFailure_ReducedMaxThrust
        failureTitle = Loss of Thrust
        failureType = mechanical
        severity = failure
        // ** PLEASE USE ONLY THESE WEIGHTS **
        // The weight of the failure is how likely it is to occur RELATIVE to other failures defined on the same part
        // 2 = Rare, 4 = Seldom, 8 = Average, 16 = Often, 32 = Common
        weight = 32
        REPAIR
        {
        	// For PHYSICAL failures
            canBeRepairedOnSplashed = False
            canBeRepairedInFlight = False
            replacementPart = NONE
            requiresEVA = False
            // For SOFTWARE failures
            // canBeRepairedByRemote
            // dataScale
            // dataSize
            // For all failures
            repairChance = 100
        }
    }
	MODULE
	{
		name = TestFlightFailure_Explode
		failureTitle = Part Exploded!
		failureType = mechanical
		severity = major
		weight = 2
	}
}
